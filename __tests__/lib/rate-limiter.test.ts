/**\n * Unit tests for rate limiter\n */\n\nimport { rateLimiter, getClientIP } from '@/lib/rate-limiter';\n\ndescribe('Rate Limiter', () => {\n  beforeEach(() => {\n    // Clear any existing rate limit data\n    rateLimiter['requests'].clear();\n  });\n\n  describe('isAllowed', () => {\n    it('should allow first request', () => {\n      const result = rateLimiter.isAllowed('test-ip');\n      expect(result).toBe(true);\n    });\n\n    it('should track multiple requests from same IP', () => {\n      const ip = 'test-ip';\n      \n      // First request should be allowed\n      expect(rateLimiter.isAllowed(ip)).toBe(true);\n      \n      // Second request should also be allowed\n      expect(rateLimiter.isAllowed(ip)).toBe(true);\n      \n      // Check remaining count decreased\n      expect(rateLimiter.getRemaining(ip)).toBeLessThan(100);\n    });\n\n    it('should block requests after limit exceeded', () => {\n      const ip = 'test-ip-blocked';\n      \n      // Make 100 requests (the default limit)\n      for (let i = 0; i < 100; i++) {\n        expect(rateLimiter.isAllowed(ip)).toBe(true);\n      }\n      \n      // 101st request should be blocked\n      expect(rateLimiter.isAllowed(ip)).toBe(false);\n    });\n\n    it('should handle different IPs independently', () => {\n      const ip1 = 'test-ip-1';\n      const ip2 = 'test-ip-2';\n      \n      expect(rateLimiter.isAllowed(ip1)).toBe(true);\n      expect(rateLimiter.isAllowed(ip2)).toBe(true);\n      \n      expect(rateLimiter.getRemaining(ip1)).toBe(99);\n      expect(rateLimiter.getRemaining(ip2)).toBe(99);\n    });\n  });\n\n  describe('getRemaining', () => {\n    it('should return max requests for new IP', () => {\n      const remaining = rateLimiter.getRemaining('new-ip');\n      expect(remaining).toBe(100);\n    });\n\n    it('should return correct remaining count', () => {\n      const ip = 'test-ip';\n      \n      rateLimiter.isAllowed(ip); // 1 request\n      expect(rateLimiter.getRemaining(ip)).toBe(99);\n      \n      rateLimiter.isAllowed(ip); // 2 requests\n      expect(rateLimiter.getRemaining(ip)).toBe(98);\n    });\n  });\n\n  describe('getResetTime', () => {\n    it('should return future reset time for active limit', () => {\n      const ip = 'test-ip';\n      const now = Date.now();\n      \n      rateLimiter.isAllowed(ip);\n      const resetTime = rateLimiter.getResetTime(ip);\n      \n      expect(resetTime).toBeGreaterThan(now);\n    });\n\n    it('should return future time for new IP', () => {\n      const now = Date.now();\n      const resetTime = rateLimiter.getResetTime('new-ip');\n      \n      expect(resetTime).toBeGreaterThan(now);\n    });\n  });\n});\n\ndescribe('getClientIP', () => {\n  it('should extract IP from x-forwarded-for header', () => {\n    const request = new Request('http://localhost', {\n      headers: {\n        'x-forwarded-for': '192.168.1.1, 10.0.0.1',\n      },\n    });\n    \n    const ip = getClientIP(request);\n    expect(ip).toBe('192.168.1.1');\n  });\n\n  it('should extract IP from x-real-ip header', () => {\n    const request = new Request('http://localhost', {\n      headers: {\n        'x-real-ip': '192.168.1.2',\n      },\n    });\n    \n    const ip = getClientIP(request);\n    expect(ip).toBe('192.168.1.2');\n  });\n\n  it('should prefer x-forwarded-for over x-real-ip', () => {\n    const request = new Request('http://localhost', {\n      headers: {\n        'x-forwarded-for': '192.168.1.1',\n        'x-real-ip': '192.168.1.2',\n      },\n    });\n    \n    const ip = getClientIP(request);\n    expect(ip).toBe('192.168.1.1');\n  });\n\n  it('should return unknown for request without IP headers', () => {\n    const request = new Request('http://localhost');\n    \n    const ip = getClientIP(request);\n    expect(ip).toBe('unknown');\n  });\n});